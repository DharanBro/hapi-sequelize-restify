const JWT = require('jsonwebtoken');

const Boom = require('@hapi/boom');
const crypto = require('crypto');
const util = require('util');

const randomBytes = util.promisify(crypto.randomBytes);
const pbkdf2 = util.promisify(crypto.pbkdf2);
let sequelize;
let authConfig;
exports.authGenerator = async (request, options) => {
    authConfig = options.config.authentication;
    let { identityKey, passcodeKey, authModel } = authConfig;
    identityKey = identityKey || 'username';
    passcodeKey = passcodeKey || 'password';
    authModel = authModel || 'User';
    if (request.payload && request.payload[identityKey] && request.payload[passcodeKey]) {
        sequelize = options.sequelize;
        const queryOptions = {
            where: {},
        };
        const username = request.payload[identityKey];
        const password = request.payload[passcodeKey];

        queryOptions.where[identityKey] = username;

        try {
            const record = await sequelize.models[authModel].findOne(queryOptions);
            if (!record) {
                return Boom.unauthorized('invalid password');
            }
            if (!exports.verifyPassword(password, record[passcodeKey])) {
                return Boom.unauthorized('invalid username');
            }

            const jwt = JWT.sign(
                { id: record.id, username: record.firstName },
                authConfig.secret, { algorithm: 'HS256', expiresIn: '24h' },
            );
            return { token: jwt, id: record.id };
        } catch (e) {
            return Boom.badImplementation('server error');
        }
    } else {
        return Boom.badData('expected params not found');
    }
};

// larger numbers mean better security, less
const config = {
    // size of the generated hash
    hashBytes: 32,
    // larger salt means hashed passwords are more resistant to rainbow table, but
    // you get diminishing returns pretty fast
    saltBytes: 16,
    // more iterations means an attacker has to take longer to brute force an
    // individual password, so larger is better. however, larger also means longer
    // to hash the password. tune so that hashing the password takes about a
    // second
    iterations: 872791,
    digest: 'sha512',
};

/**
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained buffer which can be arbitrarily encoded for storage
 * that contains all the data needed to verify a password.
 *
 * @param {!String} password
 */
exports.hashPassword = async (password) => {
    const salt = await randomBytes(config.saltBytes);
    const hash = await pbkdf2(password, salt, config.iterations, config.hashBytes, config.digest);


    const combined = [salt.toString('hex'), hash.toString('hex')].join('$');

    return combined;
};

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} password
 * @param {!Buffer} combined Buffer containing hash and salt as generated by
 *   hashPassword.
 * @param {!function(?Error, !boolean)}
 */
exports.verifyPassword = async (password, combined) => {
    // extract the salt and hash from the combined buffer
    const hash = combined.split('$')[1];
    const salt = combined.split('$')[0];
    const { iterations, hashBytes, digest } = config;
    const hashBuffer = await pbkdf2(password, salt, iterations, hashBytes, digest).toString('hex');
    return hashBuffer === hash;
};
